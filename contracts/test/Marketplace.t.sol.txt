// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/BCO2.sol";
import "../src/mocks/MockRUSD.sol";
import "../src/Governance.sol";
import "../src/Registry/ProjectFactory.sol";
import "../src/Registry/ProjectData.sol";
import "../src/Registry/ProjectManager.sol";
import "../src/Marketplace.sol";
import "../src/BCO2DAO.sol";

contract BCO2Test is Test {
    BCO2 bco2;
    MockRUSD rusd;
    BCO2Governance governance;
    BCO2DAO bco2DAO;
    ProjectData projectData;
    ProjectManager projectManager;
    ProjectFactory projectFactory;
    BCO2Marketplace marketplace;

    address user = address(1);
    address vvb = address(2);
    address owner = address(this);
    bytes32 public constant VINTAGE = keccak256("Vintage");

    
    uint256 validVintage = 1752282049;

    function setUp() public {
        rusd = new MockRUSD();
        governance = new BCO2Governance(owner);
        projectData = new ProjectData(owner, address(governance));
        projectManager = new ProjectManager(
            address(projectData),
            address(governance),
            owner
        );
        bco2DAO = new BCO2DAO(address(rusd), address(projectData), address(projectManager), address(governance));
        projectFactory = new ProjectFactory(
            address(projectData),
            address(projectManager),
            address(governance),
            address(bco2DAO),
            address(rusd),
            owner
        );
        marketplace = new BCO2Marketplace(
            address(rusd),
            address(projectData),
            owner
        );

        
        vm.warp(validVintage + 1);

        bco2 = new BCO2(
            "MAAL-0001", // projectId
            owner, // initialOwner
            1 ether, // mintPrice
            true, // isPermanent
            100, // validity
            validVintage, // vintage
            address(governance), // governance
            address(projectData), // registry
            address(bco2DAO), // BCO2 DAO
            IERC20(address(rusd)), // RUSD token
            0, // methodologyId
            "Kenya" // location
        );

        governance.initialize(address(projectData), address(projectManager), address(bco2DAO));
        projectData.setManager(address(projectManager));
        projectData.setFactory(address(projectFactory));
        governance.addVVB(vvb);

        rusd.setBalance(user, 10000 ether);

        vm.startPrank(user);
        bco2 = BCO2(
            projectFactory.createAndListProject(
                10000000000000000000,
                user,
                true,
                0,
                validVintage,
                0,
                "India",
                3000000,
                "Link to details"
            )
        );
        bco2.setTokenURI("ipfs://non-retired", "ipfs://retired");

        vm.warp(block.timestamp + 1800);
        vm.startPrank(vvb);
        governance.validateProject(address(bco2));
        governance.verifyProject(address(bco2));

        vm.startPrank(owner);
        governance.approveAndIssueCredits(address(bco2), 3000000);

        ProjectData.Project memory project = projectData.getProjectDetails(
            address(bco2)
        );

        console.log("Project ID:", project.projectId);
        console.log("Certificate ID:", project.certificateId);
        console.log("Marketplace:", address(marketplace));

        vm.startPrank(user);
        rusd.approve(address(bco2), 100 ether);
        bco2.mintWithRUSD(10); // Mint 10 tCO2 tokens

        vm.stopPrank();
    }

    function testMintAndList() public {
        vm.startPrank(user); // ‚Üê Switch sender to user

        // Assert initial balances
        assertEq(bco2.balanceOf(user, 1), 10);

        bco2.setApprovalForAll(address(marketplace), true);

        // Check listing details
        marketplace.createListing(address(bco2), 1, 5, 10000000000000000000);
        (address seller, , , , , bool active) = marketplace.listings(0);
        console.log("Listing Details:", seller, active);

        assertEq(seller, user);
        assertTrue(active);
    }
}
